<!DOCTYPE HTML>
<!--
	Massively by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Portfolio - Chris Wolyniec</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Header -->
					<header id="header">
						<h1 class="logo">Chris Wolyniec</h1>
					</header>

				<!-- Nav -->
					<nav id="nav">
						<ul class="links">
							<li><a href="index.html">About Me</a></li>
							<li class="active"><a href="portfolio.html">Portfolio</a></li>
							<li><a href="contact.html">Contact Me</a></li>
							<li><a href="CV - Chris Wolyniec.docx" download>CV Download</a></li>
						</ul>
						<ul class="icons">
							<li><a href="https://www.linkedin.com/in/christopher-wolyniec-8291b4152/" class="icon fa-linkedin"><span class="label">Linkedin</span></a></li>
							<li><a href="https://github.com/ChrisWolyniec" class="icon fa-github"><span class="label">GitHub</span></a></li>
						</ul>
					</nav>

				<!-- Main -->
					<div id="main">

						<!-- Post -->
							<section class="post">
								<header class="major">
									<h1>My past work</h1>
									<p>Here is a collection of work that I have completed to date.</p>
								</header>
							</section>
						
						
						<!-- Posts -->
					  <section class="posts">
						  
							<article>
								<header>
									<h2>Procedural Planets:</h2>
									<video width="100%" height="100%" controls>
										<source src="videos/Procedural Planets - WIP.mp4" type="video/mp4">
									</video>
								</header>
										<p><font size="3">
										For my Final Year Project, I decided to develop a tool designed to procedurally generate planet models. This is the current state of the project (as submitted), and shows the implementation of a normalised cube with a 3D height map applied to it generated from a combination of layered and ridged simplex noise.
										The texturing is also handled procedurally through a shader which blends between user specified colours depending on the terrains elevation in addition to its steepness. 
										<br>To improve the realism of the produced mesh, I also implemented a hydraulic erosion simulation that is ran after the base mesh is produced. This adds realism by smoothing out flat terrain, better defining terrain features such as mountains and adding additional elements to the model such as rivers and mountain gullies.
										<br>Another artefact was produced which made use of Voxels instead of offseting a sphere mesh using a heightmap. This method allowed for the generation of terrain features that the heightmap method could not, namely overhangs and cave systems.
										<br><br>Download the artefacts:
										<br><a href="Heightmap.zip" download>Heightmap Terrain (Heightmap.zip)</a>
										<br><a href="Voxel.zip" download>Voxel Terrain (Voxel.zip)</a>
										</font></p>
								<br>
							</article>

						 	 	<article>
									<header>
										<h2>Rome REMASTERED:</h2>
										<img width="100%" height="100%" src="images/Portfolio/RomeRemastered.jpeg" alt="Rome Remastered">
									</header>
											<p><font size="3">
											During my placement year working at Feral Interactive, I worked on Total War: Rome REMASTERED. During my time working on Rome, I worked in a variety of areas including implementing new gameplay, AI and UI features, developing new library functionality and general optimisation.<br>
											My main task was creating a new system which would allow users to easily mod the game, allowing them to tweak it to their liking. To achieve this, I implemented a file redirection system, which allowed modders to provide modified versions of the various data files in addition to the original unchanged files, with the game automatically loading the modified files.<br>
											To support this and make the experience easier for end-users, I also implemented Steam Workshop support, so users could easily download and install mods, with very little technical knowhow required.
											Since returning to Feral, I have been working on the post-release patches, with my main focus being on stability and also continuing to improve the modability of the game by working with members of the games community to provide additional functionality for them to make use of in their mods.
											</font></p>
								</article>
								
						 	 	<article>
									<header>
										<h2>Erebus - Game Engine:</h2>
										<video width="100%" height="100%" controls>
											<source src="videos/Erebus.mp4" type="video/mp4">
										</video>
									</header>
											<p><font size="3">
											In my final year of University, I worked with a group of friends to produce a 2D games engine. My main contributions to the engine were the event system, input system and the various AI releated systems such as the pathfinding and behaviour tree editor.<br>
											The input system I implemented was inspired by how the system works in UE4 and issues I found in my previous projects. I found in previous projects that I had issued when I wanted to alter which keys were bound to certain actions as all the binding were hardcoded.
											Due to this, I implemented a system similar to UE4's in which keys are bound to a keyname, and then said keyname is used in code. This level of indirection allows for keybinding to be easily altered as no code changes need to be made, just the binding in the data file. I then implemented a GUI for generating/altering said data file to make this even easier.<br>
											I also added a behaviour tree to the engine to allow users to easily create agent AI's. The feature required a programmer to create leaf nodes for controlling the agent, and then provides the choice of either creating the tree itself via code, or through a GUI. The GUI allows for alterations to the AI's logic, such as the order it performs actions and its priorities to be performed by those who may not have programming knowledge, such as designers.<br>
											
											Continuing from this project, I plan to develop my own 2D games engine, using what we learnt during this project to help me to produce an overall better project, both in terms of the code, and the usability of the engine. 
											</font></p>
								</article>
								
						 	 	<article>
									<header>
										<h2>Chess AI:</h2>
										<video width="100%" height="100%" controls>
											<source src="videos/Chess.mp4" type="video/mp4">
										</video>
									</header>
											<p><font size="3">
											This Chess AI allowed me to research into many different methods for optimising decision making. The main technique used in my AI is the minimax algorithm.<br>
											This allows the AI to look into all the possible future states of the game (limitied by either a max depth or time), and then make the move that will lead to the best outcome for itself.<br>
											However, as the amount of board states that need to be evaluated increases exponentially as the search depth increases, optimisations to the base minimax algorithm had to be made to reduce the amount of states that need to be evaluated.<br>
											The main technique used for this was alpha-beta pruning, which essentially prunes entire sections of the search tree (therefore reducing what needs to be evaluated). It does this my pruning any branches that are worse than an already evaluated branch, as they should never be chosen, and therefore dont need to be evaluated any further.<br>
											To improve upon this further, additional techniques were used to optimise alpha-beta, as it works best when the best moves are evaluated first, as more branches can be pruned this way. Method such as simply sorting the possible moves by the material gained/lost and also implementing additional techniques such as iterative deepending allowed me to achieve this.
											</font></p>
								</article>
								
						 	 	<article>
									<header>
										<h2>FlappyBird AI:</h2>
										<video width="100%" height="100%" controls>
											<source src="videos/Flappy Bird - Neural Network.mp4" type="video/mp4">
										</video>
									</header>
											<p><font size="3">
											As part of my AI module, I created a flappy bird AI that made use of neural networks and genetic algorithms in order to learn how to play the game.<br>
											The AI does this by taking data from the game such as the birds distance from the floor, distance to the pipe etc, running said data through a neural network and then using its output to decide whether the bird should flap or not.<br>
											As can be seen in the video, the initial generation of birds have entirely random behaviour due to the networks weights and biases being randomised. However by using genetic algorithms, I was able to take the best of each generation, and use them to create a new generation, with the aim of the birds score improving with each generation.
											</font></p>
								</article>

						 	 	<article>
									<header>
										<h2>AI Tank:</h2>
										<video width="100%" height="100%" controls>
											<source src="videos/AI Tank.mp4" type="video/mp4">
										</video>
									</header>
											<p><font size="3">
											As part of my second year AI module, I constructed the AI required to navigate a tank through a given maze while also collecting objectives and reacting to enemies. 
											<br>To achieve these requirements, I implemented a range of steering behaviours (namely, 'Seek', 'Flee', 'Arrive', 'Pursue', 'Avoid' and 'Wander'), and combined these with both DRS Pathfinding and obstacle avoidance. In combination, these granted by AI the ability to navigate through the maze in a timely manner without colliding with the walls of the maze.
											<br>In reaction to spotted enemies, the AI located the nearest safe spot, and navigates to it while also shooting the the enemy if its gun is correctly aimed at it. This allowed the tank to pass through the enemies located in the maze while only taking minimal damage and conserving ammo.
											</font></p>
								</article>
								
								<article>
									<header>
										<h2>Ukie Game Jam 2020:</h2>
										<video width="100%" height="100%" controls>
											<source src="videos/Ukie GameJam 2020.mp4" type="video/mp4">
										</video>
									</header>
											<p><font size="3">
											During my final year at Uni, me and a few friends decided to enter into another Game Jam, this time joining the Ukie student Game Jam. 
											<br>The game features a character who gets cursed and becomes increasingly frustrated with everything around them and is forced to release their rage and frustraction on unsuspecting villagers, else let their bloodlust and rage consume them, while at the same time, avoid being caught.
											<br>The curse however does provide them with some abilities. These abilities were designed in order to support the player in their task of killing villagers without being caught (e.g. if you get caught, you could go back in time before you were spotted).
											<br>My main contribution to the game was the time-reversal mechanic. It would revert the game back to its state from from 8 seconds prior. This included reverting the players position, their bloodlust, the AI's positions, the AI's task list and pathing, bring any killed AI's back to life (only those that died during the previous 8 seconds) as well as revert the players caught state back to what it was previously.
											Unfortunately, as the majority of this required the AI systems to function, which were added close to the deadline, I was unable to fully implement the different AI requirements and merge them into the main branch before the deadline was reached, resuting in only the players state being reverted.
											<br><br>
											<a href="https://overahill.itch.io/somebodies-bad-day">Our Submission</a>
											</font></p>
									<br>
								</article>
						
								<article>
									<header>
										<h2>Boids / Flocking:</h2>
										<video width="100%" height="100%" controls>
											<source src="videos/Flocking.mp4" type="video/mp4">
										</video>
									</header>
											<p><font size="3">
											For my final year AI module, I was tasked with implementing an example of Artificial Life in the form of flocking. I did this by following the model first published by Craig Reynolds using the simple rules of 'seperation', 'alignment' and 'cohesion' in order to create the complex behaviour that is flocking.
											<br>I then took this a step further by implementing a predator into the simulation that kills the 'birds'. This allowed me to further develop the model as I could grant each bird different characteristics, in order to observe which best suited survival in the given environment.
											This could be developed further using evolutionary algorithms in order to 'breed' the best birds of each generation in order to improve the characteristics of the birds going into the next generation, until they can survive against the predator.
											</font></p>
									<br>
								</article>
						  
								<article>
									<header>
										<h2>Group Game Project:</h2>
										<video width="100%" height="100%" controls>
											<source src="videos/TGP Group.mp4" type="video/mp4">
										</video>
									</header>
											<p><font size="3">
											In a project I worked on with four other students, we produced a first person puzzle game in UE4 which took inspiration from the 'Portal' series. The game consisted on the player being able to colour certain objects within the world, which each colour providing different traits that affect its surroundings. The player would have to strategically make their way through the puzzels, unlocking additional colours as they progress in order to produce new ways of completing puzzles. 
											This project allowed us to further develop our skills with UE4 while also granting us experience in multiple areas we had not experienced before, or had little knowledge on (such as UI, collisions, shaders, etc).
											</font></p>
								</article>
						  
						  
						 		 <article>
									<header>
										<h2>Rigidbody Physics:</h2>
										<video width="100%" height="100%" controls>
											<source src="videos/Rigidbody Physics.mp4" type="video/mp4">
										</video>
									</header>
											<p><font size="3">
											For my graphics and physics module in second year, I was assigned with creating a rigidbody physics engine in Direct3D that focused on realistic collision interactions between 3D objects. Collisions were originally handled using only simple bounding spheres and boxes, however when implementing many objects in the world this caused the collision code to come to a crawl as I was having to run the collision code O(N^2) as each object had to be compared against every other object. To fix this issue, I used the bounding spheres and boxes alongside a basic octree implemention to reduce the amount of needed collision checks.
											<br>In addition to the rigidbody collisions, I also implemented a particle system which makes use of a object pool in order to cut down on the amount of memory allocations taking place.
											</font></p>
									<br>
								</article>
						  
								<article>
									<header>
										<h2>Super Mario Bros:</h2>
										<video width="100%" height="100%" controls>
											<source src="videos/Super Mario Bros.mp4" type="video/mp4">
										</video>
									</header>
											<p><font size="3">
											As my second venture into games programming, this 'Super Mario Bros' clone introduced me to the SDL2 Library, game audio and also very basic enemy AI. This project was also my first attempt at implementing a text renderer from scratch.
											</font></p>
									<br><br>
								</article>

						  		<article>
									<header>
										<h2>Splodey Guys:</h2>
										<video width="100%" height="100%" controls>
											<source src="videos/Splodey Guys.mp4" type="video/mp4">
										</video>
									</header>
											<p><font size="3">
											This was the first game that I created and it was done using the Universities proprietary API called S2D. It is a basic two player clone of 'Bomberman' with various power ups dropped from the crates when they are designed. While basic, it intoduced me to the fundamentals of games programming and a better understanding of what goes into making a game.
											</font></p>
									<br>
								</article>
								
							</section>
						
					</div>
				

				<!-- Copyright -->
					<div id="copyright">
						<ul><li>Christopher Wolyniec</li><li>Design: <a href="https://html5up.net">HTML5 UP</a></li></ul>
					</div>

			</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>